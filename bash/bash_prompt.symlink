c_repo_clean='\[\033[32;1m\]'
c_repo_dirty='\[\033[31;1m\]'
c_reset='\[\033[0m\]'
c_user='\[\033[33m\]'
c_host='\[\033[34m\]'
c_path='\[\033[36m\]'

working_directory() {
    echo "${c_user}\u${c_reset}@${c_host}\h${c_reset} ${c_path}\w${c_reset}"
}

parse_git_branch() {
    local_branch=$(git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    changes=$(git status -sb | wc -l)

    if [ $changes -gt '1' ]; then
        echo " ${c_repo_dirty}$local_branch${c_reset}"
    else
        echo " ${c_repo_clean}$local_branch${c_reset}"
    fi
}

parse_remote_state() {
    remote_state=$(git status -sb 2> /dev/null | grep -oh "\[.*\]")
    if [[ "$remote_state" != "" ]]; then
        out="${c_reset}"

        if [[ "$remote_state" == *ahead* ]] && [[ "$remote_state" == *behind* ]]; then
            behind_num=$(echo "$remote_state" | grep -oh "behind \d*" | grep -oh "\d*$")
            ahead_num=$(echo "$remote_state" | grep -oh "ahead \d*" | grep -oh "\d*$")
            out="$out${c_repo_dirty}$behind_num${c_reset},${c_repo_clean}$ahead_num${c_reset}"

        elif [[ "$remote_state" == *ahead* ]]; then
            ahead_num=$(echo "$remote_state" | grep -oh "ahead \d*" | grep -oh "\d*$")
            out="$out${c_repo_clean}$ahead_num${c_reset}"

        elif [[ "$remote_state" == *behind* ]]; then
            behind_num=$(echo "$remote_state" | grep -oh "behind \d*" | grep -oh "\d*$")
            out="$out${c_repo_dirty}$behind_num${c_reset}"
        fi

        out="$out${c_reset}"
        echo " -> $out"
    fi
}

parse_repo() {
    if [ -d .git ]; then
        echo "$(parse_git_branch)$(parse_remote_state)"
    elif [ -d .svn ]; then
        echo ""
    fi
}

prompt() {
    PS1="\n[$(working_directory)$(parse_repo)]\n$ "
}

PROMPT_COMMAND=prompt